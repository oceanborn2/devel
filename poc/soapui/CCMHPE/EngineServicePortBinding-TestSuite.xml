<?xml version="1.0" encoding="UTF-8"?>
<con:testSuite name="EngineServicePortBinding TestSuite" xmlns:con="http://eviware.com/soapui/config"><con:settings/><con:runType>SEQUENTIAL</con:runType><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="ComposeReturnStream" searchProperties="true" id="bde84daa-c848-40cb-a745-ec8d54cbe308"><con:description>This testcase configures the composition request so that a stream is returned directly within the HTTP response.</con:description><con:settings/><con:testStep type="request" name="ComposeStream"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="ComposeStream"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting><con:setting id="com.eviware.soapui.impl.support.AbstractHttpRequest@follow-redirects">true</con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:8080/EngineService/EngineService</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
                <!--Optional:-->
               <driver>PEN1c3RvbWVyPg0KPERvYz5IZWxsb1dvcmxkPC9Eb2M+DQo8L0N1c3RvbWVyPg==</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>
            <!--Optional:-->
            <!--pubFile>HelloWorld.pub</pubFile-->
            <pubFile>HelloWorld_DLF_Full_Encryption.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>
]]></con:request><con:credentials><con:username/><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig action="urn:hpexstream-services/Engine:EngineWebService:ComposeRequest" mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:testStep type="groovy" name="decodeMockedStream"><con:settings/><con:config><script>// mock the PDF stream as a base64 string 
def pdfStream = 'JVBERi0xLjUKMSAwIG9iago8PCAvQ3JlYXRvciAoSFAgRXhzdHJlYW0gVmVyc2lvbiA5LjAuMTA0IDY0LWJpdCAoREJDUykpCi9DcmVhdGlvbkRhdGUgKDIvNC8yMDE1IDE0OjUwOjQ4KQovQXV0aG9yIChSZWdpc3RlcmVkIHRvOiBTR1BSQkFOSykKL1RpdGxlIChIZWxsb1dvcmxkX0FwcCkKPj4KZW5kb2JqCiVQREYgRm9udCAoRjQwKQo2ICAgICAwIG9iago8PAovVHlwZSAvRm9udAovU3VidHlwZSAvVHlwZTEKL0Jhc2VGb250IC9UaW1lcy1Cb2xkCj4+CmVuZG9iagolUERGIEZvbnQgKEY5MCkKNyAgICAgMCBvYmoKPDwKL1R5cGUgL0ZvbnQKL1N1YnR5cGUgL1R5cGUxCi9CYXNlRm9udCAvVGltZXMtUm9tYW4KPj4KZW5kb2JqCjEwIDAgb2JqCjw8L0xlbmd0aCA0NDgvRmlsdGVyWy9BU0NJSTg1RGVjb2RlL0ZsYXRlRGVjb2RlXT4+c3RyZWFtCkdhdCR1YkErbWomSC5rc1dcaGlRN3BdRSNYaWokdV01YVQ/PXRKJ08oIyZZOFBNRV5jXE9gQSpgUF1ANjNBWDhJQ0otZSZyME9sO29xKj8pcWlQUHA7PVtPPSdkYmo7NmUrN0ljODNsdS8jXUleW1Y9SShIZ1QqcTRmQFMvQk8oZVxRNzpwX3FlJT4mL0soXDg9O20vNi5kclErXC86cGIiQTYkODguSSwjV3RDZSJALGwiMF51R14mTFJqQSI1cG1aRWpaNDFaMD9FRjtTVGleWVAhK2VXSypMTTkzJmFbcFVKRUxHQCcoMT1tSVkiaGYtIVk7OyYzN1lCMHFjLkFHKDoqZyJYNVwxXmAvVyhtQCxHMj1CWjVTYyJpQSVEJmYzXXM7T2kvV2F1Lik/aEg/PV8iYFpBOSE1Llh0NDgqYUBdbUEnTzBDZT0yP1coMzlyLTw9KG1UcS1hMmolLFA2OkRBOUY+J0woXzFXT108TVg3ZENgcSR1RUQ6R0VrblYqb1gqYm5gZ1RUais/aChKX00oOT4yX2IjKlZAJjVuVWREJy1iPmpZWUAqK3RfP0VQalkoKWRmMW05Y01+PgoKZW5kc3RyZWFtCmVuZG9iagoxMSAwIG9iago8PC9UeXBlL1BhZ2UvUGFyZW50IDEyIDAgUi9Db250ZW50cyAxMCAwIFIvUmVzb3VyY2VzIDUgMCBSPj4KZW5kb2JqCjEyIDAgb2JqCjw8L1R5cGUvUGFnZXMvQ291bnQgMS9LaWRzWzExIDAgUl0vTWVkaWFCb3hbMCAwIDYxMiA3OTJdL1Jlc291cmNlcyA1IDAgUj4+CmVuZG9iago1IDAgb2JqCjw8L1Byb2NTZXRbL1BERi9JbWFnZUIvSW1hZ2VDL1RleHRdL0ZvbnQ8PC9GNDAgNiAwIFIgCi9GOTAgNyAwIFIgPj4KPj4KZW5kb2JqCjggMCBvYmoKPDwvVGl0bGUgKP7/ADEAOgAgKS9EZXN0WzExIDAgUi9YWVogOTk5IDk5OSAwXS9QYXJlbnQgMyAwIFIvRmlyc3QgOSAwIFIvTGFzdCA5IDAgUi9Db3VudCAtMT4+CgplbmRvYmoKOSAwIG9iago8PC9UaXRsZSAo/v8ASABlAGwAbABvAFcAbwByAGwAZABfAEQAbwBjKS9EZXN0WzExIDAgUi9YWVogOTk5IDk5OSAwXS9QYXJlbnQgOCAwIFI+PgoKZW5kb2JqCjMgMCBvYmoKPDwgL0NvdW50IDEgL0ZpcnN0IDggMCBSIC9MYXN0IDggMCBSID4+CmVuZG9iagoyIDAgb2JqCjw8L1R5cGUvQ2F0YWxvZy9QYWdlcyAxMiAwIFIvT3V0bGluZXMgMyAwIFIvUGFnZU1vZGUvVXNlT3V0bGluZXM+PgplbmRvYmoKeHJlZgowIDEzCjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDAwOSAwMDAwMCBuIAowMDAwMDAxNDA5IDAwMDAwIG4gCjAwMDAwMDEzNTQgMDAwMDAgbiAKMDAwMDAwMDAwMCAwMDAwMCBmIAowMDAwMDAxMDU4IDAwMDAwIG4gCjAwMDAwMDAxOTEgMDAwMDAgbiAKMDAwMDAwMDI4MiAwMDAwMCBuIAowMDAwMDAxMTQ0IDAwMDAwIG4gCjAwMDAwMDEyNTQgMDAwMDAgbiAKMDAwMDAwMDM1OCAwMDAwMCBuIAowMDAwMDAwODkwIDAwMDAwIG4gCjAwMDAwMDA5NjcgMDAwMDAgbiAKdHJhaWxlcjw8L1NpemUgMTMvSW5mbyAxIDAgUi9Sb290IDIgMCBSCj4+CnN0YXJ0eHJlZgoxNDkxCiUlRU9GCg=='

// mock the engine message
def engMsg = 'ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCiAqIEhQIEV4c3RyZWFtIFZlcnNpb24gOS4wLjEwNCA2NC1iaXQgKERCQ1MpDQogKiBFeGVjdXRpb24gQmVnaW5zOiAyLzQvMjAxNSAgIDE0OjUwOjQ4DQogKiBNZXNzYWdlIEZpbGUgICgxNjM1MTUpDQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCiAqICAgICAgICAgU3VtbWFyeSBvZiBFeHN0cmVhbSBSdW4gT3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqDQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICogICBSdW4gQXMtT2YgRGF0ZTogICAgICAgICBNb250aCAoMikgIERheSAoNCkgIFllYXIgKDIwMTUpDQogKiAgIENvbnRyb2wgRmlsZTogICAgICAgICAgIEM6XEhwRXhzdHJlYW1cU2NyYXRjaFxIZWxsb1dvcmxkOWRlNDA1MThkMzFmNGJlMTg1N2JkMGFlOTFhNGYwZTlcY29udHJvbC5vcHQNCiAqICAgQ29udHJvbCBGaWxlIEVuY29kaW5nOiAgSVNPODg1OTENCiAqICAgUGFja2FnZSBGaWxlICggIDEpOiAgICAgQzpcSHBFeHN0cmVhbVxQYWNrYWdlc1xIZWxsb1dvcmxkLnB1YiAtLSBBcHBsaWNhdGlvbiBQYWNrYWdlDQogKiAgIE1lc3NhZ2UgRmlsZTogICAgICAgICAgIEM6XEhwRXhzdHJlYW1cU2NyYXRjaFxIZWxsb1dvcmxkOWRlNDA1MThkMzFmNGJlMTg1N2JkMGFlOTFhNGYwZTlcbWVzc2FnZXMuZGF0DQogKiAgIFJlcG9ydCAgRmlsZTogICAgICAgICAgIEV4c3RyZWFtUmVwb3J0LmRhdA0KICogICBUcmFjayAgIEZpbGU6ICAgICAgICAgICBFeHN0cmVhbVRyYWNrLmRhdA0KICogICBOb24tUXVldWUgT3V0cHV0IEZpbGU6ICBDOlxIcEV4c3RyZWFtXFNjcmF0Y2hcSGVsbG9Xb3JsZDlkZTQwNTE4ZDMxZjRiZTE4NTdiZDBhZTkxYTRmMGU5XEhlbGxvV29ybGQub3V0DQogKiAgIE91dHB1dCBEaXJlY3Rvcnk6ICBDOlxIcEV4c3RyZWFtXFNjcmF0Y2hcSGVsbG9Xb3JsZDlkZTQwNTE4ZDMxZjRiZTE4NTdiZDBhZTkxYTRmMGU5XA0KICogICBSdW4gTW9kZTogICAgICAgICAgICAgICBQcm9kdWN0aW9uDQogKiAgIENvbXBpbGVkIEVuZ2luZSBUeXBlOiAgIFJlbGVhc2UgUHJvZHVjdGlvbg0KICogICBQcm9ncmFtIEZ1bmN0aW9uczogICAgICBDb21wb3NpdGlvbg0KICogICBFcnJvciBTdG9wIExldmVsOiAgICAgICBTZXZlcmUNCiAqICAgUG9zdCBTb3J0IE1vZGU6ICAgICAgICAgTm8NCiAqICAgQ3JlYXRlIE91dHB1dCBGaWxlczogICAgWWVzDQogKiAgIERpc2FibGUgUHJpbnQgRmlsZXM6ICAgIE5vDQogKiAgIERpc2FibGUgT3V0cHV0IFNvcnQ6ICAgIE5vDQogKiAgIENhbXBhaWduIFJlcG9ydCBMZXZlbDogIE5vbmUNCiAqICAgVHJhY2tpbmcgRFNOOiAgICAgICAgICAgRXhzdHJlYW0gVHJhY2tpbmcgOS4wLjEwNA0KICogICBUcmFja2luZyBTY2hlbWE6ICAgICAgICBOb25lDQogKiAgIFRyYWNraW5nIFR5cGU6ICAgICAgICAgIEZpbGUNCiAqICAgVHJhY2tpbmcgSW5wdXQ6ICAgICAgICAgTm9uZSAoZGlzYWJsZSBhY3Rpdml0eS1iYXNlZCBjYW1wYWlnbnMpDQogKiAgIFZlcmJvc2UgUHJvZ3Jlc3M6ICAgICAgIEF1dG9tYXRpYw0KICogICBPdmVybGF5IE1vZGU6ICAgICAgICAgICBCYXNlZCBPbiBQcmludGVyDQogKiAgIE1heGltdW0gT3ZlcmxheXM6ICAgICAgIEJhc2VkIE9uIFByaW50ZXINCiAqICAgSW1wb3J0IERpcmVjdG9yeTogICAgICAgDQogKiAgIFByb2Nlc3MgQ3VzdG9tZXJzOiAgICAgIDAgdG8gOTk5OTk5OTk5IGJ5IDENCiAqICAgRmlsZSBNYXBwaW5nOiAgICAgICAgICAgMSBGaWxlcyBBcmUgTWFwcGVkDQogKiAgICAgICBJTlBVVCAgPT09PiAgQzpcSHBFeHN0cmVhbVxTY3JhdGNoXEhlbGxvV29ybGQ5ZGU0MDUxOGQzMWY0YmUxODU3YmQwYWU5MWE0ZjBlOVxJTlBVVCAgIA0KICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQogKiAgICAgICAgIFBhY2thZ2UgRmlsZSBPdmVydmlldyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKg0KICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCiAqICAgQ3JlYXRpb24gRGF0ZSA6ICAgICAgICAgMDEvMjgvMjAxNSAgMTE6NDMNCiAqICAgQ3JlYXRlZCBCeSA6ICAgICAgICAgICAgYWRtaW4NCiAqICAgRGVzaWduIE1hbmFnZXIgVmVyc2lvbiA6OTAwMTA0DQogKiAgIFBhY2thZ2UgQ29udGVudHM6ICAgICAgIENvbXBsZXRlDQogKiAgIFBhY2thZ2UgVHlwZTogICAgICAgICAgIEZ1bGwgQXBwbGljYXRpb24gUGFja2FnZQ0KICogICBBcHBsaWNhdGlvbjogICAgICAgICAgICBIZWxsb1dvcmxkX0FwcA0KICogICBBcHBsaWNhdGlvbiByZXZpc2VkIDogICAwMS8yOC8yMDE1ICAxMTo0Mg0KICogICBBcHBsaWNhdGlvbiB2ZXJzaW9uIDogICAxDQogKiAgIFBhY2thZ2UgT2JqZWN0IFZlcnNpb246IFdJUCBmb3IgYWxsIHVzZXJzDQogKiAgIFBhY2thZ2UgQXMtb2YgRGF0ZTogICAgIE5vdyAoMDEvMjgvMjAxNSAgMTE6NDMpDQogKiAgIEFwcGxpY2F0aW9uIFF1ZXVlczogICAgIEVuYWJsZWQNCiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQogKiAgIE91dHB1dCB3aWxsIGJlIHdyaXR0ZW4gdG8gUXVldWUgZmlsZXMsIG5vdCB0aGUgTm9uLVF1ZXVlIE91dHB1dCBGaWxlDQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICogICBSdWxlcyBvbiBRdWV1ZXMgcHJvY2Vzc2VkIEFGVEVSIGNvbXBvc2l0aW9uIGJlY2F1c2Ugb2YgdmFyaWFibGVzIHVzZWQgaW4gcnVsZXMuDQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KIERyYXdQYXJ0IFBETCBQcmludCBNZW1vcnkgLSBUb3RhbDogIDEyMDU4DQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KIE51bWJlciBvZiBtZXNzYWdlcyBpc3N1ZWQ6ICAgICAzICAgIHRvdGFsIGNhbGxlZDogIDMNCiBOdW1iZXIgb2YgY3VzdG9tZXJzIHByb2Nlc3NlZDogMQ0KIE51bWJlciBvZiBjdXN0b21lciBjb21tdW5pY2F0aW9ucyBwcm9kdWNlZDogMQ0KIE51bWJlciBvZiBwYWdlcyBwcm9jZXNzZWQ6ICAgICAxICAgICgwIGJsYW5rKQ0KIFByb2dyYW0gc3RhcnQgJiBlbmQ6ICAgICAgICAgICAwMi8wNC8yMDE1IDE0OjUwOjQ4IC0gMTQ6NTA6NDgNCiBFbGFwc2VkIHdhbGwgY2xvY2sgdGltZTogICAgICAgMDA6MDA6MDANCiBFbGFwc2VkIENQVSB0aW1lOiAgICAgICAgICAgICAgMC4wMSAgc2VjIFNFVFVQICAwLjAxICBzZWMgVE9UQUwNCiBDUFUgUGVyZm9ybWFuY2U6ICAgICAgICAgICAgICAgMzYwMDAwIFBncy9IciAgMTAwLjAgUGdzL1NlYw0KIFdhbGwgY2xvY2sgcGVyZm9ybWFuY2U6ICAgICAgICBDYW5ub3QgYmUgY2FsY3VsYXRlZA0K'

def base64toString (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
	new String(decBytes)
}

def getStringAsArray(String fullText) {
	def lines = []
	fullText.split("\r\n").each { String it -> lines.add(it) } //collect() //each ( it -> 
	lines
}

def display (lines) {
	log.info('\r\n\r\n')
	lines.each { it -> log.info(it) }
}
// decode both pdf stream and engine message
pdfStreamLines = getStringAsArray(base64toString(pdfStream))
assert pdfStreamLines.size() > 0
assert pdfStreamLines[0].startsWith('%PDF-1.5') 
display(pdfStreamLines)

engMsgLine = getStringAsArray(base64toString(engMsg))
display(engMsgLine)

'OK'
</script></con:config></con:testStep><con:testStep type="groovy" name="decodeRealStream"><con:settings/><con:config><script>def base64toString (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
	new String(decBytes)
}

def getStringAsArray(String fullText) {
	def lines = []
	fullText.split("\r\n").each { String it -> lines.add(it) } //collect() //each ( it -> 
	lines
}


def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context);  
def stepBase = testRunner.testCase.testSteps["ComposeStream"]; 
stepBase.run(testRunner, context)

def xmlResult = stepBase.testRequest.response.getContentAsXml(); 

// get a holder object to deal with XPATH 
def responseHolder = groovyUtils.getXmlHolder(xmlResult)

// extract the result
def commandLines = responseHolder.getNodeValues("//fileOutput/text()")
log.info commandLines.getClass().getName() + " " + commandLines.size() + " lines found";  // ----------------------  // retrieve the properties step object def configPropsStep = testRunner.testCase.testSteps["configTest"];  // read the 2 properties within it def nbOrdersToCreate = Integer.valueOf(configPropsStep.getPropertyValue("nbOrdersToCreate")); def nbLinesPerOrder = Integer.valueOf(configPropsStep.getPropertyValue("nbLinesPerOrder"));  // compute the amount of line to build def numRows = nbOrdersToCreate * nbLinesPerOrder;  // retrieve the SOAP step : createOrder def createOrderStep = testRunner.testCase.testSteps["createOrder"];  def count = 0; StringBuilder ordersToDelete = new StringBuilder(); for(def i=1; i&lt;=nbOrdersToCreate; i++) {     StringBuilder lines = new StringBuilder();     for(def j=1; j&lt;=nbLinesPerOrder; j++) {         int index = i>1 ? (i-1) * nbLinesPerOrder + j-1 : i*j-1;         lines.append(OrderLines.getAt(index));     }       // transfer the Orderlines as String into the temp properties step     tempProps.setPropertyValue("orderlines", lines.toString());     tempProps.setPropertyValue("numOrder", String.valueOf(count++));       // run the SOAP step Create     testRunner.runTestStep(createOrderStep);       // retrieve the SOAP response as XML     def xmlRespCreate = createOrderStep.testRequest.response.getContentAsXml();     def createHolder = groovyUtils.getXmlHolder(xmlRespCreate);        // assume that the createOrder operation returns an order code in the right tag     def OrderCode = createHolder.getNodeValue("//OrderCode");        // build the string to put in the deleteOrder SOAP step     ordersToDelete.append("&lt;OrderCode>" + OrderCode + "&lt;/OrderCode>"); }  // finally, transfert this String into the temp properties step. tempProps.setPropertyValue("ordersToDelete

commandLines.each { commandLine ->
	log.info(getStringAsArray(base64toString(commandLine)))
}

'COMPLETED OK'</script></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="ComposeReturnURL" searchProperties="true" id="aa7b9e53-3441-4be5-9a73-c3a85c805108"><con:description>This testcase configures the composition request so that an URL is returned to the caller which must then do a GET operation in order to retrieve the document. </con:description><con:settings/><con:testStep type="request" name="ComposeURL"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="ComposeURL"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting><con:setting id="com.eviware.soapui.impl.support.AbstractHttpRequest@follow-redirects">true</con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:8080/EngineService/EngineService</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
               <!--Optional:-->
               <driver>PEN1c3RvbWVyPg0KPERvYz5IZWxsb1dvcmxkPC9Eb2M+DQo8L0N1c3RvbWVyPg==</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <fileReturnRegEx>true</fileReturnRegEx>
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>
            <!--Optional:-->
            <!--Optional:-->
            <outputFile>
               <!--Optional:-->
               <directory>identifiant_Unique</directory>
               <!--Optional:-->
               <fileName>identifiant.pdf</fileName>
            </outputFile>
            <!--Optional:-->
            <pubFile>HelloWorld.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>
]]></con:request><con:credentials><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig action="urn:hpexstream-services/Engine:EngineWebService:ComposeRequest" mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:testStep type="groovy" name="decodeRealURL"><con:settings/><con:config><script><![CDATA[def base64toString (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
	new String(decBytes)
}

def getStringAsArray(String fullText) {
	def lines = []
	fullText.split("\r\n").each { String it -> lines.add(it) }  
	lines
}

def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context);  
def stepBase = testRunner.testCase.testSteps["ComposeURL"]; 
stepBase.run(testRunner, context)

def xmlResult = stepBase.testRequest.response.getContentAsXml(); 
log.info(xmlResult)

// get a holder object to deal with XPATH 
def responseHolder = groovyUtils.getXmlHolder(xmlResult)

// extract the result
def commandLines = responseHolder.getNodeValues("//engineMessage/text()")
log.info commandLines.getClass().getName() + " " + commandLines.size() + " lines found";  // ----------------------  // retrieve the properties step object def configPropsStep = testRunner.testCase.testSteps["configTest"];  // read the 2 properties within it def nbOrdersToCreate = Integer.valueOf(configPropsStep.getPropertyValue("nbOrdersToCreate")); def nbLinesPerOrder = Integer.valueOf(configPropsStep.getPropertyValue("nbLinesPerOrder"));  // compute the amount of line to build def numRows = nbOrdersToCreate * nbLinesPerOrder;  // retrieve the SOAP step : createOrder def createOrderStep = testRunner.testCase.testSteps["createOrder"];  def count = 0; StringBuilder ordersToDelete = new StringBuilder(); for(def i=1; i<=nbOrdersToCreate; i++) {     StringBuilder lines = new StringBuilder();     for(def j=1; j<=nbLinesPerOrder; j++) {         int index = i>1 ? (i-1) * nbLinesPerOrder + j-1 : i*j-1;         lines.append(OrderLines.getAt(index));     }       // transfer the Orderlines as String into the temp properties step     tempProps.setPropertyValue("orderlines", lines.toString());     tempProps.setPropertyValue("numOrder", String.valueOf(count++));       // run the SOAP step Create     testRunner.runTestStep(createOrderStep);       // retrieve the SOAP response as XML     def xmlRespCreate = createOrderStep.testRequest.response.getContentAsXml();     def createHolder = groovyUtils.getXmlHolder(xmlRespCreate);        // assume that the createOrder operation returns an order code in the right tag     def OrderCode = createHolder.getNodeValue("//OrderCode");        // build the string to put in the deleteOrder SOAP step     ordersToDelete.append("<OrderCode>" + OrderCode + "</OrderCode>"); }  // finally, transfert this String into the temp properties step. tempProps.setPropertyValue("ordersToDelete
commandLines.each { commandLine ->
	getStringAsArray(base64toString(commandLine)).each  { line ->
		log.info(line)
	}
}

log.info("> ____________ RESPONSE START ________________")
def responseLines  = responseHolder.getNodeValues("//fileOutput/text()")
log.info responseLines.getClass().getName() + " " + responseLines.size() + " lines found";  // ----------------------  // retrieve the properties step object def configPropsStep = testRunner.testCase.testSteps["configTest"];  // read the 2 properties within it def nbOrdersToCreate = Integer.valueOf(configPropsStep.getPropertyValue("nbOrdersToCreate")); def nbLinesPerOrder = Integer.valueOf(configPropsStep.getPropertyValue("nbLinesPerOrder"));  // compute the amount of line to build def numRows = nbOrdersToCreate * nbLinesPerOrder;  // retrieve the SOAP step : createOrder def createOrderStep = testRunner.testCase.testSteps["createOrder"];  def count = 0; StringBuilder ordersToDelete = new StringBuilder(); for(def i=1; i<=nbOrdersToCreate; i++) {     StringBuilder lines = new StringBuilder();     for(def j=1; j<=nbLinesPerOrder; j++) {         int index = i>1 ? (i-1) * nbLinesPerOrder + j-1 : i*j-1;         lines.append(OrderLines.getAt(index));     }       // transfer the Orderlines as String into the temp properties step     tempProps.setPropertyValue("orderlines", lines.toString());     tempProps.setPropertyValue("numOrder", String.valueOf(count++));       // run the SOAP step Create     testRunner.runTestStep(createOrderStep);       // retrieve the SOAP response as XML     def xmlRespCreate = createOrderStep.testRequest.response.getContentAsXml();     def createHolder = groovyUtils.getXmlHolder(xmlRespCreate);        // assume that the createOrder operation returns an order code in the right tag     def OrderCode = createHolder.getNodeValue("//OrderCode");        // build the string to put in the deleteOrder SOAP step     ordersToDelete.append("<OrderCode>" + OrderCode + "</OrderCode>"); }  // finally, transfert this String into the temp properties step. tempProps.setPropertyValue("ordersToDelete
responseLines.each { resp ->
	getStringAsArray(base64toString(resp)).each { line -> log.info(line) }
}
log.info("> ____________ RESPONSE END __________________")

'COMPLETED OK']]></script></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="InteractiveScenarioDirectStream" searchProperties="true"><con:settings/><con:testStep type="request" name="Requete_DLF_DS"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="Requete_DLF_DS"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:8081/EngineService/EngineService</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
               <!--Optional:-->
               <driver>PEN1c3RvbWVyPg0KPERvYz5IZWxsb1dvcmxkPC9Eb2M+DQo8L0N1c3RvbWVyPg==</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>
            <!--Optional:-->
            <pubFile>HelloWorld_DLF_Full_Encryption.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:assertion type="SOAP Response"/><con:credentials><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:testStep type="groovy" name="DirectStreamScenario"><con:settings/><con:config><script>// 1st step: Run the SOAP request against the EWS web service and retrieve the base64 encoded response
// Either continue or stop based on error status
def step1RequestDLF() {
	// grab the testcase and run it
	def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context);  
	def stepBase = testRunner.testCase.testSteps["Requete_DLF_DS"]; 
	stepBase.run(testRunner, context)

	// retrieve the returning XML stream
	def xmlResult = stepBase.testRequest.response.getContentAsXml(); 
	log.info(xmlResult)
	
	// get a holder object to deal with XPATH 
	def responseHolder = groovyUtils.getXmlHolder(xmlResult)

	response = responseHolder.getNodeValues("//fileOutput/text()")
	log.info("response size : " + response[0].size())
	def httpResponse = context.expand( '${Test Request: login#Response}' )
	log.info(httpResponse)
	//log.info(">>>" + response[0] +"&lt;&lt;&lt;")
	response[0]
}

// decode from base64 and store into a template.dlf file
def step2DecodeAndStoreDLF(String text) {
	
	String HOMEDIR = "D:/X118372/CCM/poc/CCMHPE"
//	String currDir = new File(".").getAbsolutePath()
//	log.info(currDir)

	File b64 = new  File("${HOMEDIR}/template.base64.txt")
	if (b64.exists()) {
		b64.delete()
	}
	b64.createNewFile()
	b64.setBytes(text.bytes)		 	

	// Write decoded response to DLF file
	byte[] response = base64toBytes(text) //bytes 	
	File f = new File("${HOMEDIR}/template.dlf")
	if (f.exists()) {
		f.delete()
	}
	f.createNewFile()
	f.setBytes(response)		 
	
	//"${HOMEDIR}/template.dlf"
	"${HOMEDIR}/template.dlf"
}

def step3RunLiveEditor(List&lt;String> params) {
	def cmdLineArgs = params.join(" ")
	runLiveEditor(cmdLineArgs)
}

// *************************************************************
// Scenario entry point
// actual program storage folder
def response = step1RequestDLF()
def dlfPath  = step2DecodeAndStoreDLF(response)
step3RunLiveEditor([dlfPath])

'COMPLETED OK'



// *************************************************************
// utility functions
//

// decode a base64 string to a stream of bytes
def base64toBytes (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
}

// decode a base64 string to a cleartext string
def base64toString (String s) {
	new String(base64toBytes(s))
}

// split a string and return an array of string
// splitting is done based on the sep character sequence
def getStringAsArray(String fullText,sep="\r\n") {
	def lines = []
	fullText.split(sep).each { String it -> lines.add(it) }  
	lines
}


// run the live editor
def runLiveEditor(cmdLine) {
	//def LEPath = 'C:/Program Files (x86)/Hewlett-Packard/HP Exstream/LiveEditor 4.0.104/Live.exe'
	def LEPath = 'C:/Program Files (x86)/Internet Explorer/iexplore.exe'
	def command = "${LEPath} ${cmdLine}"      // Create the String
	def proc = command.execute()    // Call *execute* on the string
	proc.waitFor()                  // Wait for the command to finish
}</script></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="InteractiveScenarioURL" searchProperties="true"><con:settings/><con:testStep type="request" name="Requete_DLF_URL"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="Requete_DLF_URL"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:8081/EngineService/EngineService</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
               <!--Optional:-->
               <driver>PEN1c3RvbWVyPg0KPERvYz5IZWxsb1dvcmxkPC9Eb2M+DQo8L0N1c3RvbWVyPg==</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>

              <outputFile>
               <!--Optional:-->
               <directory>identifiant_Unique</directory>
               <!--Optional:-->
               <fileName>identifiant.pdf</fileName>
            </outputFile>
            
            <!--Optional:-->
            <pubFile>HelloWorld_DLF_Full_Encryption.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:assertion type="SOAP Response"/><con:credentials><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:testStep type="groovy" name="URLScenario"><con:settings/><con:config><script>// 1st step: Run the SOAP request against the EWS web service and retrieve the base64 encoded response
// Either continue or stop based on error status
def step1RequestDLF() {
	// grab the testcase and run it
	def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context);  
	def stepBase = testRunner.testCase.testSteps["Requete_DLF_URL"]; 
	stepBase.run(testRunner, context)

	// retrieve the returning XML stream
	def xmlResult = stepBase.testRequest.response.getContentAsXml(); 
	log.info(xmlResult)
	
	// get a holder object to deal with XPATH 
	def responseHolder = groovyUtils.getXmlHolder(xmlResult)

	response = responseHolder.getNodeValues("//fileOutput/text()")
	log.info("response size : " + response[0].size())
	def httpResponse = context.expand( '${Test Request: login#Response}' )
	log.info(httpResponse)
	//log.info(">>>" + response[0] +"&lt;&lt;&lt;")
	response[0]
}

// decode from base64 and store into a template.dlf file
def step2DecodeAndStoreDLF(String text) {
	
	String HOMEDIR = "D:/X118372/CCM/poc/CCMHPE"
//	String currDir = new File(".").getAbsolutePath()
//	log.info(currDir)

	File b64 = new  File("${HOMEDIR}/template.base64.txt")
	if (b64.exists()) {
		b64.delete()
	}
	b64.createNewFile()
	b64.setBytes(text.bytes)		 	

	// Write decoded response to DLF file
	byte[] response = base64toBytes(text) //bytes 	
	File f = new File("${HOMEDIR}/template.dlf")
	if (f.exists()) {
		f.delete()
	}
	f.createNewFile()
	f.setBytes(response)		 
	
	//"${HOMEDIR}/template.dlf"
	"${HOMEDIR}/template.dlf"
}

def step3RunLiveEditor(List&lt;String> params) {
	def cmdLineArgs = params.join(" ")
	runLiveEditor(cmdLineArgs)
}

// *************************************************************
// Scenario entry point
// actual program storage folder
def response = step1RequestDLF()
def dlfPath  = step2DecodeAndStoreDLF(response)
step3RunLiveEditor([dlfPath])

'COMPLETED OK'



// *************************************************************
// utility functions
//

// decode a base64 string to a stream of bytes
def base64toBytes (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
}

// decode a base64 string to a cleartext string
def base64toString (String s) {
	new String(base64toBytes(s))
}

// split a string and return an array of string
// splitting is done based on the sep character sequence
def getStringAsArray(String fullText,sep="\r\n") {
	def lines = []
	fullText.split(sep).each { String it -> lines.add(it) }  
	lines
}


// run the live editor
def runLiveEditor(cmdLine) {
	//def LEPath = 'C:/Program Files (x86)/Hewlett-Packard/HP Exstream/LiveEditor 4.0.104/Live.exe'
	def LEPath = 'C:/Program Files (x86)/Internet Explorer/iexplore.exe'
	def command = "${LEPath} ${cmdLine}"      // Create the String
	def proc = command.execute()    // Call *execute* on the string
	proc.waitFor()                  // Wait for the command to finish
}</script></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="RunDLFFromIE" searchProperties="true"><con:settings/><con:testStep type="groovy" name="RunDLFFromExistingFile"><con:settings/><con:config><script>// run the live editor
def runLiveEditorWithinIE(cmdLine) {
	//def LEPath = 'C:/Program Files (x86)/Hewlett-Packard/HP Exstream/LiveEditor 4.0.104/Live.exe'
	def LEPath = 'C:/Program Files (x86)/Internet Explorer/iexplore.exe'
	def command = "${LEPath} ${cmdLine}"      // Create the String
	def proc = command.execute()    // Call *execute* on the string
	proc.waitFor()                  // Wait for the command to finish
}

String HOMEDIR = "D:/X118372/CCM/poc/CCMHPE"
runLiveEditorWithinIE("${HOMEDIR}/prefilled.dlf")</script></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="SOAPInject" searchProperties="true" disabled="true"><con:settings/><con:testStep type="request" name="Requete_PDF" disabled="true"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="Requete_PDF"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:8080/EngineService/EngineService</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
               <!--Optional:-->
               <driver>PEN1c3RvbWVyPg0KPERvYz5IZWxsb1dvcmxkPC9Eb2M+DQo8L0N1c3RvbWVyPg==</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>
            <!--Optional:-->
            <pubFile>HelloWorld_PDF.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:assertion type="SOAP Response"/><con:credentials><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:testStep type="groovy" name="RunDLF" disabled="true"><con:settings/><con:config><script><![CDATA[// 1st step: Run the SOAP request against the EWS web service and retrieve the base64 encoded response
// Either continue or stop based on error status
def step1ReadDLFAsSOAP() {
	File f = new File("template.dlf")
	String encodedDLF
	int length = -1;
	if (f.exists()) {
		length = f.size()
		def b = new byte[length]
		fis = new	FileInputStream(f).read(b)
		encodedDLF = bytesToBase64(b)
	} else {
		throw new Exception("Cannot read file")
	}
	
"""<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:eng="urn:hpexstream-services/Engine">
   <soapenv:Header/>
   <soapenv:Body>
      <eng:Compose>
         <!--Optional:-->
         <EWSComposeRequest>
            <!--Optional:-->
            <driver>
               <!--Optional:-->
               <driver>${encodedDLF}</driver>
               <!--Optional:-->
               <fileName>INPUT</fileName>
            </driver>
            <!--Zero or more repetitions:-->
            <engineOptions>
               <!--Optional:-->
               <name>TRACKIN</name>
               <!--Optional:-->
               <value>DISABLE</value>
            </engineOptions>
            <!--Optional:-->
            <includeHeader>true</includeHeader>
            <includeMessageFile>true</includeMessageFile>
            <!--Optional:-->
            <pubFile>HelloWorld_Full_Encryption_DLF.pub</pubFile>
         </EWSComposeRequest>
      </eng:Compose>
   </soapenv:Body>
</soapenv:Envelope>"""
}


def step2RunDLF(encodedDLF) {
	// grab the testcase and run it
	def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context);  
	def stepBase = testRunner.testCase.testSteps["Requete_DLF"]; 
	stepBase.setContent(encodedDLF)	
	stepBase.run(testRunner, context)
/*
	// retrieve the returning XML stream
	def xmlResult = stepBase.testRequest.response.getContentAsXml(); 
	log.info(xmlResult)
	
	// get a holder object to deal with XPATH 
	def responseHolder = groovyUtils.getXmlHolder(xmlResult)

	response = responseHolder.getNodeValues("//fileOutput/text()")
	log.info("response size : " + response[0].size())
	def httpResponse = context.expand( '${Test Request: login#Response}' )
	log.info(httpResponse)
	//log.info(">>>" + response[0] +"<<<")
	response[0]

	*/
}

// decode from base64 and store into a template.dlf file
def step2DecodeAndStoreDLF(String text) {
	/*
	String HOMEDIR = "D:/X118372/CCM/poc/CCMHPE"
//	String currDir = new File(".").getAbsolutePath()
//	log.info(currDir)

	File b64 = new  File("${HOMEDIR}/template.base64.txt")
	if (b64.exists()) {
		b64.delete()
	}
	b64.createNewFile()
	b64.setBytes(text.bytes)		 	

	// Write decoded response to DLF file
	byte[] response = base64toBytes(text) //bytes 	
	File f = new File("${HOMEDIR}/template.dlf")
	if (f.exists()) {
		f.delete()
	}
	f.createNewFile()
	f.setBytes(response)		 
	
	"${HOMEDIR}/template.dlf" 
	*/
}

def step3RunLiveEditor(List<String> params) {
	def cmdLineArgs = params.join(" ")
	runLiveEditor(cmdLineArgs)
}

// *************************************************************
// Scenario entry point
// actual program storage folder
def soapRequest = step1ReadDLFAsSOAP()
log.info(soapRequest)
step2RunDLF(soapRequest)
//def dlfPath  = step2DecodeAndStoreDLF(response)
//step3RunLiveEditor([dlfPath])

'COMPLETED OK'



// *************************************************************
// utility functions
//

// decode a base64 string to a stream of bytes
def base64toBytes (String s) {
	if (s.size()==0 || s.trim().size() == 0) { '' } 
	byte[] decBytes = s.decodeBase64()
}

def bytesToBase64(byte[] b) {
	if (b.size()==0) { return "" }
	s = b.encodeBase64()
}

// decode a base64 string to a cleartext string
def base64toString (String s) {
	new String(base64toBytes(s))
}

// split a string and return an array of string
// splitting is done based on the sep character sequence
def getStringAsArray(String fullText,sep="\r\n") {
	def lines = []
	fullText.split(sep).each { String it -> lines.add(it) }  
	lines
}


// run the live editor
def runLiveEditor(cmdLine) {
	//def LEPath = 'C:/Program Files (x86)/Hewlett-Packard/HP Exstream/LiveEditor 4.0.104/Live.exe'
	def LEPath = 'C:/Program Files (x86)/Internet Explorer/iexplore.exe'
	def command = "${LEPath} ${cmdLine}"      // Create the String
	def proc = command.execute()    // Call *execute* on the string
	proc.waitFor()                  // Wait for the command to finish
}]]></script></con:config></con:testStep><con:testStep type="request" name="Requete_DLF" disabled="true"><con:settings/><con:config xsi:type="con:RequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:interface>EngineServicePortBinding</con:interface><con:operation>Compose</con:operation><con:request name="Requete_DLF"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://FR05168618D:8088/mockEngineServicePortBinding</con:endpoint><con:request/><con:assertion type="SOAP Response"/><con:credentials><con:authType>No Authorization</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508"/><con:wsrmConfig version="1.2"/></con:request></con:config></con:testStep><con:properties/></con:testCase><con:testCase failOnError="true" failTestCaseOnErrors="true" keepSession="false" maxResults="0" name="SecureProxy" searchProperties="true"><con:settings/><con:testStep type="groovy" name="ProxyService"><con:settings/><con:config><script>import groovy.net.soap.SoapServer
import groovy.net.soap.SoapClient
import java.security.SecureRandom
 
class EWSProxyService {

	final PROXY_URL = 'http://localhost:8080/EngineService/EngineService?wsdl'
	final SecureRandom secRand = new SecureRandom()
	
	def EWSProxyService() {
		proxy.initSecret()	
	}
	
	// initialize a secret key between the application and the proxy - this must be a true random sequence hence the use
	// of SecureRandom
	def initSecret() {
		secRand.nextLong()	
	}
	
	def compose() {
		def proxy = new SoapClient(PROXY_URL)		
	
	}

}


def server = new SoapServer("localhost", 6980)
server.setNode("EWSProxyService")
server.start()


</script></con:config></con:testStep><con:testStep type="groovy" name="ClientApplication"><con:settings/><con:config><script>import groovy.net.soap.SoapClient

def proxy = new SoapClient("http://localhost:6980/EWSProxyService?wsdl")

def secretkey = proxy.initSecret()
println("secret key:" + secretkey)
def result = proxy.compose()
 </script></con:config></con:testStep><con:properties/></con:testCase><con:properties/></con:testSuite>